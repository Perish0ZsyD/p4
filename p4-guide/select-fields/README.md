# Example code implementing one possible 'SelectFields' behavior

The code here is related to the following Github issue for the P4_16
PSA specification, titled "PSA Consider creating new extern for
selecting small set of keys from large set of keys":

    https://github.com/p4lang/p4-spec/issues/516

The motivation is to allow a P4 program to specify a large collection
of fields, e.g. 40 bytes worth, but at packet forwarding time only a
subset of those fields are selected, e.g. 16 bytes out of the
specified 40.

As can be seen from the code here, there is no need to create a new
extern to implement such functionality.  The P4_16 language operators
are sufficient.

The only reason to consider creating a new extern for this is
efficiency of implementing this behavior in some kinds of hardware
targets, e.g. those that are similar to the RMT architecture, and
perhaps others.

One way to write this in a P4 program would permit the choice of 16
out of 40 bytes to change from one packet to the next, based on the
contents of the packet.  For example, the packet itself might contain
16 6-bit values in it, where each 6-bit value specifies one of the 40
bytes to select.  I am not claiming this is useful for any known
network protocols -- it is simply an example where if you wanted to do
that, it means that the field selection is very dynamic.

Another way, in fact the way that motivates the creation of a new
extern, is to say that the choice of which 16 bytes is selected from
the 40 can _only_ change when the control plane software makes an
appropriate API call.

Why is this distinction important?

It makes possible implementations that consume fewer hardware
resources.  For example, in an RMT-like architecture, perhaps making
the control plane API call might change the operands in one or more
VLIW instructions, or to config registers for some hardware
multiplexors.  It is expected that there are existing and/or planned
P4 implementations where these selections are straightforward to
change at control plane operation time (i.e. a very slow time scale
relative to packets arriving), but very difficult to change based on
contents of arriving packets.

Below is an example implementation of this behavior in P4_16 code with
no new externs.  It is an excerpt from the file `select-fields4.p4`,
which was generated by running this command:

```bash
% ./gen-select-fields4.py > select-fields4.p4
```

The file `select-fields4.p4` contains many nearly-identical `control`
definitions, that differ only in the values of 16 and 40 from the
example mentioned above.  The excerpt below select 2 bytes out of 4
input bytes, as indicated by the `4_to_2` in the names.

```p4
control Select8BitFields_4_to_2_select_one_field(
    in bit<32> data_in,
    in bit<2> sel,
    out bit<8> one_out_field)
{
    apply {
        one_out_field =
              ((sel == 3) ? data_in[31:24]
            : ((sel == 2) ? data_in[23:16]
            : ((sel == 1) ? data_in[15:8]
            : data_in[7:0])));
    }
}

control Select8BitFields_4_to_2_pure_function(
    in bit<32> data_in,
    in bit<4> select_control,
    out bit<16> data_out)
{
    bit<8> out1;
    bit<8> out0;
    Select8BitFields_4_to_2_select_one_field() sof;
    apply {
        sof.apply(data_in, select_control[3:2], out1);
        sof.apply(data_in, select_control[1:0], out0);
        data_out = (
            out1 ++
            out0
            );
    }
}

control Select8BitFields_4_to_2(
    in bit<32> data_in,
    out bit<16> data_out)
{
    Select8BitFields_4_to_2_pure_function() sf;
    bit<4> select_control;

    action get_sc(bit<4> sc) {
        select_control = sc;
    }
    table get_select_control {
        key = { }
        actions = { get_sc; }
        default_action = get_sc(0);
    }

    apply {
        get_select_control.apply();
        sf.apply(data_in, select_control, data_out);
    }
}
```

The control `Select8BitFields_4_to_2_select_one_field` takes the 4
bytes (32 bit) input as `data_in`, a 2-bit selector `sel` that
specifies one of the 4 bytes to select, and returns the specified byte
in the `one_out_field` parameter.

The control `Select8BitFields_4_to_2_pure_function` makes two calls to
the previous control, one for each of the two bytes of output in
`data_out`.  It uses different subsets of bits in its `select_control`
input to control the selection of the two output bytes.

Both of the controls above are "pure" functions, meaning that their
behavior and return values depend upon nothing but the values of their
input parameters.  They have no internal state maintained across
calls, and their behavior does not depend upon any state that isn't in
their input parameters.

The control `Select8BitFields_4_to_2` is simply a call to the last
pure function control above, after using a P4 table to retrieve the
selection of output bytes that should be made, as specified by the
control plane software.

Possible choices:

(1) Add only the pure functions as new extern functions in PSA.

(2) Add only the stateful version that contains a table as a new extern
    object in PSA.

(3) Add both.

(4) Add nothing like these things to PSA.

If we made choice (1), it would still be possible for a compiler to
make optimizations similar to choice (2), but the compiler would need
to do a bit more work to identify that the P4_16 code was written in a
way that allowed it to make similar optimizations as (2).

For example, the compiler could see a call to a pure function from
(1), and analyze how the value of the `select_control` input is
determined.  If that value is the output of a table, with no
modifications made to the value since it came from the table output,
then the same kinds of optimizations as if extern object (2) existed
could be made by the compiler.  Perhaps an additional restriction
would be on the size of the table, e.g. at most one entry like in the
example control `Select8BitFields_4_to_2`, or perhaps an
implementation would support a table with more such entries.

If the value of `select_control` was determined in any other way, the
implementation might be significantly more expensive in that target.
The compiler could even indicate in some output whether it used the
more or less efficient implementation for a particular call to the
functions in style (1), and why.


# Differences between example reference implementations here

The files `select-fields1.p4` through `select-fields4.p4` were
generated by these commands:

```bash
% ./gen-select-fields1.py > select-fields1.p4
% ./gen-select-fields2.py > select-fields2.p4
% ./gen-select-fields3.py > select-fields3.p4
% ./gen-select-fields4.py > select-fields4.p4
```

These are at most minor variations on how to write this behavior,
which should all have equivalent input/output behavior.

The motivation for writing multiple variations was that I was testing
the code through a tool
[`p4pktgen`](https://github.com/p4pktgen/p4pktgen) that has
significantly larger output when there are many `if` conditions in the
code, vs. when there are not.


## `select-fields1.p4`

This one as written is limited to 'fields' that have widths with
powers of 2.  It could easily be extended to field widths without that
restriction, as long as the P4 implementation supported multiplication
of a run-time variable with a compile-time constant.  It uses the
right shift operator `>>` to extract out the desired fields from
`data_in`.


## `select-fields2.p4`

This one, and all later ones below, supports fields of any width, not
only those with width that is a power of 2.

`select-fields2.p4` uses chains of `if-then-else-if` statements to
implement what would be written in many other languages as a `switch`
or `case` statement.


## `select-fields3.p4`

This is the same as `select-fields2.p4`, except it reduces the size
and repetitiveness of the code by creating a separate control that
extracts one output field, and then calls that once for each output
field.


## `select-fields4.p4`

This is the same as `select-fields3.p4`, except that it uses a
daisy-chained ternary operator instead of a chain of `if-then-else-if`
statements to calculate the value of one output field.  Its logical
structure and behavior is otherwise identical.

I learned that at least the current version of `p4c-bm2-ss` compiles
this to something with if condition nodes nearly identical in
structure to `select-fields3.p4`.  I was hoping it might use the
ternary operator in the bmv2 JSON expressions, but there must be some
stage of the compiler that is transforming those into equivalent if
statements.
