program : input END ;
input
    : /* empty */
    | input declaration
    | input ";"             // empty declaration
    ;

declaration
    : constantDeclaration
    | externDeclaration
    | actionDeclaration
    | parserDeclaration
    | typeDeclaration
    | controlDeclaration
    | instantiation
    | errorDeclaration
    | matchKindDeclaration
    | functionDeclaration
    ;

nonTypeName
    : IDENTIFIER
    | APPLY
    | KEY
    | ACTIONS
    | STATE
    | ENTRIES
    | TYPE
    ;

name
    : nonTypeName
    | LIST
    | TYPE_IDENTIFIER
    ;

nonTableKwName
    : IDENTIFIER
    | TYPE_IDENTIFIER
    | APPLY
    | STATE
    | TYPE
    ;

optCONST
    : /* empty */
    | CONST
    ;

optAnnotations
    : /* empty */
    | annotations
    ;

annotations
    : annotation
    | annotations annotation
    ;

annotation
    : "@" name
    | "@" name "(" annotationBody ")"
    | "@" name "[" expressionList "]"
    | "@" name "[" kvList "]"
    // Experimental: backwards compatibility with P4-14 pragmas (which
    // themselves are experimental!)
    | PRAGMA name annotationBody END_PRAGMA
    ;

annotationBody
    : /* empty */
    | annotationBody "(" annotationBody ")"
    | annotationBody annotationToken
    ;

annotationToken
    : UNEXPECTED_TOKEN
    | ABSTRACT
    | ACTION
    | ACTIONS
    | APPLY
    | BOOL
    | BIT
    | CONST
    | CONTROL
    | DEFAULT
    | ELSE
    | ENTRIES
    | ENUM
    | ERROR
    | EXIT
    | EXTERN
    | FALSE
    | HEADER
    | HEADER_UNION
    | IF
    | IN
    | INOUT
    | INT
    | KEY
    | MATCH_KIND
    | TYPE
    | OUT
    | PARSER
    | PACKAGE
    | PRAGMA
    | RETURN
    | SELECT
    | STATE
    | STRING
    | STRUCT
    | SWITCH
    | TABLE
    | THIS
    | TRANSITION
    | TRUE
    | TUPLE
    | TYPEDEF
    | VARBIT
    | VALUESET
    | LIST
    | VOID
    | "_"
    | IDENTIFIER
    | TYPE_IDENTIFIER
    | STRING_LITERAL
    | INTEGER
    | "&&&"
    | ".."
    | "<<"
    | "&&"
    | "||"
    | "=="
    | "!="
    | ">="
    | "<="
    | "++"
    | "+"
    | "|+|"
    | "-"
    | "|-|"
    | "*"
    | "/"
    | "%"
    | "|"
    | "&"
    | "^"
    | "~"
    // Omit parens. These are handled in annotationBody, since they must be
    // balanced.
    // | "("
    // | ")"
    | "["
    | "]"
    | "{"
    | "}"
    | "<"
    | L_ANGLE_ARGS
    | ">"
    | R_ANGLE_SHIFT
    | "!"
    | ":"
    | ","
    | "?"
    | "."
    | "="
    | ";"
    | "@"
    ;

kvList
    : kvPair
    | kvList "," kvPair
    ;

kvPair
    : name "=" expression
    ;

parameterList
    : /* empty */
    | nonEmptyParameterList
    ;

nonEmptyParameterList
    : parameter
    | nonEmptyParameterList "," parameter
    ;

parameter
    : optAnnotations direction typeRef name
    | optAnnotations direction typeRef name "=" expression
    ;

direction
    : IN
    | OUT
    | INOUT
    | /* empty */
    ;

packageTypeDeclaration
    : optAnnotations PACKAGE name
      optTypeParameters
      "(" parameterList ")"
    ;

instantiation
      : annotations typeRef "(" argumentList ")" name ";"
      | typeRef "(" argumentList ")" name ";"
      | annotations typeRef "(" argumentList ")" name "=" objInitializer ";"
      | typeRef "(" argumentList ")" name "=" objInitializer ";"
    ;

objInitializer
    : "{"  objDeclarations "}"
    ;

objDeclarations
    : /* empty */
    | objDeclarations objDeclaration
    ;

objDeclaration
    : functionDeclaration
    | instantiation
    ;

optConstructorParameters
    : /* empty */
    | "(" parameterList ")"
    ;

dotPrefix
    : "."
    ;

/**************************** PARSER ******************************/

parserDeclaration
    : parserTypeDeclaration optConstructorParameters
      "{" parserLocalElements parserStates "}"
    ;

parserLocalElements
    : /* empty */
    | parserLocalElements parserLocalElement
    ;

parserLocalElement
    : constantDeclaration
    | instantiation
    | variableDeclaration
    | valueSetDeclaration
    ;

parserTypeDeclaration
    : optAnnotations
        PARSER name
        optTypeParameters
        "(" parameterList ")"
    ;

parserStates
    : parserState
    | parserStates parserState
    ;

parserState
    : optAnnotations STATE name
      "{" parserStatements transitionStatement "}"
    ;

parserStatements
    : /* empty */
    | parserStatements parserStatement
    ;

parserStatement
    : assignmentOrMethodCallStatement
    | directApplication
    | emptyStatement
    | variableDeclaration
    | constantDeclaration
    | parserBlockStatement
    | conditionalStatement
    ;

parserBlockStatement
    : optAnnotations "{"
      parserStatements "}"
    ;

transitionStatement
    : /* empty */
    | TRANSITION stateExpression
    ;

stateExpression
    : name ";"
    | selectExpression
    ;

selectExpression
    : SELECT "(" expressionList ")" "{" selectCaseList "}"
    ;

selectCaseList
    : /* empty */
    | selectCaseList selectCase
    ;

selectCase
    : keysetExpression ":" name ";"
    ;

keysetExpression
    : tupleKeysetExpression
    | simpleKeysetExpression
    ;

tupleKeysetExpression
    : "(" simpleKeysetExpression "," simpleExpressionList ")"
    | "(" reducedSimpleKeysetExpression ")"
    ;

simpleExpressionList
    : simpleKeysetExpression
    | simpleExpressionList "," simpleKeysetExpression
    ;

reducedSimpleKeysetExpression
    // like simpleKeysetExpression, but without 'expression', to avoid a conflict
    : expression "&&&" expression
    | expression ".." expression
    | DEFAULT
    | "_"
    ;

simpleKeysetExpression
    : expression
    | expression "&&&" expression
    | expression ".." expression
    | DEFAULT
    | "_"
    ;

valueSetDeclaration
    : optAnnotations
        VALUESET "<" baseType ">" "(" expression ")" name ";"
    | optAnnotations
        VALUESET "<" tupleType ">" "(" expression ")" name ";"
    | optAnnotations
        VALUESET "<" typeName ">" "(" expression ")" name ";"
    ;

/*************************** CONTROL ************************/

controlDeclaration
    : controlTypeDeclaration optConstructorParameters
      "{" controlLocalDeclarations APPLY controlBody "}"
    ;

controlTypeDeclaration
    : optAnnotations
        CONTROL name
        optTypeParameters
        "(" parameterList ")"
    ;

controlLocalDeclarations
    : /* empty */
    | controlLocalDeclarations controlLocalDeclaration
    ;

controlLocalDeclaration
    : constantDeclaration
    | actionDeclaration
    | tableDeclaration
    | instantiation
    | variableDeclaration
    ;

controlBody
    : blockStatement
    ;

/*************************** EXTERN *************************/

externDeclaration
    : optAnnotations
        EXTERN nonTypeName
        optTypeParameters
        "{" methodPrototypes "}"
    | optAnnotations EXTERN functionPrototype ";"
    | optAnnotations EXTERN name ";"
    ;

methodPrototypes
    : /* empty */
    | methodPrototypes methodPrototype
    ;

functionPrototype
    : typeOrVoid
        name optTypeParameters
        "(" parameterList ")"
    ;

methodPrototype
    : optAnnotations functionPrototype ";"
    | optAnnotations ABSTRACT functionPrototype ";"
    | optAnnotations TYPE_IDENTIFIER "(" parameterList ")" ";"  // constructor
    ;

/************************** TYPES ****************************/

typeRef
    : baseType
    | typeName
    | specializedType
    | headerStackType
    | p4listType
    | tupleType
    ;

namedType
    : typeName
    | specializedType
    ;

prefixedType
    : TYPE_IDENTIFIER
    | dotPrefix TYPE_IDENTIFIER
    ;

typeName
    : prefixedType
    ;

p4listType
    : LIST "<" typeArg ">"
    ;

tupleType
    : TUPLE "<" typeArgumentList ">"
    ;

headerStackType
    : typeName "[" expression "]"
    | specializedType "[" expression "]"
    ;

specializedType
    : typeName "<" typeArgumentList ">"
    ;

baseType
    : BOOL
    | MATCH_KIND
    | ERROR
    | BIT
    | STRING
    | INT
    | BIT "<" INTEGER ">"
    | INT "<" INTEGER ">"
    | VARBIT "<" INTEGER ">"
    | BIT "<" "(" expression ")" ">"
    | INT "<" "(" expression ")" ">"
    | VARBIT "<" "(" expression ")" ">"
    ;

typeOrVoid
    : typeRef
    | VOID
    | IDENTIFIER
        // This is necessary because template arguments may introduce the return type
    ;

optTypeParameters
    : /* empty */
    | typeParameters
    ;

typeParameters
    : "<" typeParameterList ">"
    ;

typeParameterList
    : name
    | typeParameterList "," name
    ;

typeArg
    : typeRef
    | nonTypeName
        // This is necessary because template arguments may introduce the return type
    | VOID
    | "_"
    ;

typeArgumentList
    : /* empty */
    | typeArg
    | typeArgumentList "," typeArg
    ;

realTypeArg
    : typeRef
    | VOID
    | "_"
    ;

// For use in contexts where the `<` might be a less-than rather than introducing a type
// argument list -- we only allow the token after `<` to be a TYPE_IDENTIFIER, not an ID
realTypeArgumentList
    : realTypeArg
    | realTypeArgumentList "," typeArg
    ;

typeDeclaration
    : derivedTypeDeclaration
    | typedefDeclaration ";"
    | parserTypeDeclaration ";"
    | controlTypeDeclaration ";"
    | packageTypeDeclaration ";"
    ;

derivedTypeDeclaration
    : headerTypeDeclaration
    | headerUnionDeclaration
    | structTypeDeclaration
    | enumDeclaration
    ;

headerTypeDeclaration
    : optAnnotations HEADER name  optTypeParameters
      "{" structFieldList "}"
    ;

structTypeDeclaration
    : optAnnotations STRUCT name   optTypeParameters
      "{" structFieldList "}"
    ;

headerUnionDeclaration
    : optAnnotations HEADER_UNION name  optTypeParameters
      "{" structFieldList "}"
    ;

structFieldList
    : /* empty */
    | structFieldList structField
    ;

structField
    : optAnnotations typeRef name ";"
    ;

enumDeclaration
    : optAnnotations
        ENUM name
        "{" identifierList "}"
    | optAnnotations ENUM typeRef name
	 "{" specifiedIdentifierList "}"
    ;

specifiedIdentifierList
    : specifiedIdentifier
    | specifiedIdentifierList "," specifiedIdentifier
    ;

specifiedIdentifier
    : name "=" initializer
    ;

errorDeclaration
    : ERROR "{" identifierList "}"
    ;

matchKindDeclaration
    : MATCH_KIND "{" identifierList "}"
    ;

identifierList
    : name
    | identifierList "," name
    ;

typedefDeclaration
    : optAnnotations TYPEDEF typeRef name
    | optAnnotations TYPEDEF derivedTypeDeclaration name
    | optAnnotations TYPE typeRef name
    ;

/*************************** STATEMENTS *************************/

assignmentOrMethodCallStatement
    // These rules are overly permissive, but they avoid some conflicts
    : lvalue "(" argumentList ")" ";"
    | lvalue "<" typeArgumentList ">" "(" argumentList ")" ";"
    | lvalue "=" expression ";"
    ;

emptyStatement
    : ";"
    ;

exitStatement
    : EXIT ";"
    ;

returnStatement
    : RETURN ";"
    | RETURN expression ";"
    ;

conditionalStatement
    : IF "(" expression ")" statement                 %prec THEN
    | IF "(" expression ")" statement ELSE statement  %prec THEN
    ;

// To support direct invocation of a control or parser without instantiation
directApplication
    : typeName "." APPLY "(" argumentList ")" ";"
    | specializedType "." APPLY "(" argumentList ")" ";"
    ;

statement
    : assignmentOrMethodCallStatement
    | directApplication
    | conditionalStatement
    | emptyStatement
    | blockStatement
    | returnStatement
    | exitStatement
    | switchStatement
    ;

blockStatement
    : optAnnotations "{"
      statOrDeclList "}"
    ;

statOrDeclList
    : /* empty */
    | statOrDeclList statementOrDeclaration
    ;

switchStatement
    : SWITCH "(" expression ")" "{" switchCases "}"
    ;

switchCases
    : /* empty */
    | switchCases switchCase
    ;

switchCase
    : switchLabel ":" blockStatement
    | switchLabel ":"
    ;

switchLabel
    : DEFAULT
    | nonBraceExpression
    ;

statementOrDeclaration
    : variableDeclaration
    | constantDeclaration
    | statement
    | instantiation
    ;

/************************* TABLE *********************************/

tableDeclaration
    : optAnnotations
        TABLE name "{" tablePropertyList "}"
    ;

tablePropertyList
    : tableProperty
    | tablePropertyList tableProperty
    ;

tableProperty
    : KEY "=" "{" keyElementList "}"
    | ACTIONS "=" "{" actionList "}"
    | optAnnotations optCONST ENTRIES "=" "{" entriesList "}"
    | optAnnotations optCONST nonTableKwName "=" initializer ";"
    ;

keyElementList
    : /* empty */
    | keyElementList keyElement
    ;

keyElement
    : expression ":" name optAnnotations ";"
    ;

actionList
    : /* empty */
    | actionList optAnnotations actionRef ";"
    ;

actionRef
    : prefixedNonTypeName
    | prefixedNonTypeName "(" argumentList ")"
    ;

entry
    : keysetExpression ":" actionRef optAnnotations ";"
    ;

entriesList
    : /* empty */
    | entriesList entry
    ;

/************************* ACTION ********************************/

actionDeclaration
    : optAnnotations ACTION name "(" parameterList ")" blockStatement
    ;

/************************* VARIABLES *****************************/

variableDeclaration
    : annotations typeRef name optInitializer ";"
    | typeRef name optInitializer ";"
    ;

constantDeclaration
    : optAnnotations CONST typeRef name "=" initializer ";"
    ;

optInitializer
    : /* empty */
    | "=" initializer
    ;

initializer
    : expression
    ;

/**************** Expressions ****************/

functionDeclaration
    : functionPrototype blockStatement
    ;

argumentList
    : /* empty */
    | nonEmptyArgList
    ;

nonEmptyArgList
    : argument
    | nonEmptyArgList "," argument
    ;

argument
    : expression
    | name "=" expression
    | "_"
    | name "=" "_"
    ;

expressionList
    : /* empty */
    | expression
    | expressionList "," expression
    ;

prefixedNonTypeName
    : nonTypeName
    | dotPrefix nonTypeName
    ;

dot_name:
    "."  name
lvalue
    : prefixedNonTypeName
    | THIS
    | lvalue dot_name %prec DOT
    | lvalue "[" expression "]"
    | lvalue "[" expression ":" expression "]"
    ;

expression
    : INTEGER
    | STRING_LITERAL
    | TRUE
    | FALSE
    | THIS
    | prefixedNonTypeName
    | expression "[" expression "]"
    | expression "[" expression ":" expression "]"
    | "{" expressionList "}"
    | "{" SHARP "}"
    | "{" kvList "}"
    | "(" expression ")"
    | "!" expression %prec PREFIX
    | "~" expression %prec PREFIX
    | "-" expression %prec PREFIX
    | "+" expression %prec PREFIX
    | typeName dot_name %prec DOT
    | ERROR "." name
    | expression dot_name %prec DOT
    | expression "*" expression
    | expression "/" expression
    | expression "%" expression
    | expression "+" expression
    | expression "-" expression
    | expression "|+|" expression
    | expression "|-|" expression
    | expression "<<" expression
    | expression R_ANGLE_SHIFT ">" expression %prec R_ANGLE_SHIFT
    | expression "<=" expression
    | expression ">=" expression
    | expression "<" expression %prec "<"
    | expression ">" expression
    | expression "!=" expression
    | expression "==" expression
    | expression "&" expression
    | expression "^" expression
    | expression "|" expression
    | expression "++" expression
    | expression "&&" expression
    | expression "||" expression
    | expression "?" expression ":" expression
    | expression "<" realTypeArgumentList ">" "(" argumentList ")"
    | expression "(" argumentList ")"
    | namedType "(" argumentList ")"
    | "(" typeRef ")" expression %prec PREFIX
    ;

nonBraceExpression
    : INTEGER
    | STRING_LITERAL
    | TRUE
    | FALSE
    | THIS
    | prefixedNonTypeName
    | nonBraceExpression "[" expression "]"
    | nonBraceExpression "[" expression ":" expression "]"
    | "(" expression ")"
    | "!" expression %prec PREFIX
    | "~" expression %prec PREFIX
    | "-" expression %prec PREFIX
    | "+" expression %prec PREFIX
    | typeName dot_name %prec DOT
    | ERROR "." name
    | nonBraceExpression dot_name %prec DOT
    | nonBraceExpression "*" expression
    | nonBraceExpression "/" expression
    | nonBraceExpression "%" expression
    | nonBraceExpression "+" expression
    | nonBraceExpression "-" expression
    | nonBraceExpression "|+|" expression
    | nonBraceExpression "|-|" expression
    | nonBraceExpression "<<" expression
    | nonBraceExpression R_ANGLE_SHIFT ">" expression %prec R_ANGLE_SHIFT
    | nonBraceExpression "<=" expression
    | nonBraceExpression ">=" expression
    | nonBraceExpression "<" expression %prec "<"
    | nonBraceExpression ">" expression
    | nonBraceExpression "!=" expression
    | nonBraceExpression "==" expression
    | nonBraceExpression "&" expression
    | nonBraceExpression "^" expression
    | nonBraceExpression "|" expression
    | nonBraceExpression "++" expression
    | nonBraceExpression "&&" expression
    | nonBraceExpression "||" expression
    | nonBraceExpression "?" expression ":" expression
    | nonBraceExpression "<" realTypeArgumentList ">" "(" argumentList ")"
    | nonBraceExpression "(" argumentList ")"
    | namedType "(" argumentList ")"
    | "(" typeRef ")" expression %prec PREFIX
    ;

intOrStr
    : INTEGER
    | STRING_LITERAL
    ;

intList
    : INTEGER
    | intList "," INTEGER
    ;

intOrStrList
    : intOrStr
    | intOrStrList "," intOrStr
    ;

strList
    : STRING_LITERAL
    | strList "," STRING_LITERAL
    ;

"<" : "<" | L_ANGLE_ARGS ;
">" : ">" | R_ANGLE_SHIFT ;

/*****************************************************************************/

%%

void P4::P4Parser::error(const Util::SourceInfo& location,
                         const std::string& message)
